# -*- coding: utf-8 -*-
"""RV_Orbital_Fitting.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fGOXkXoreXtIPh961LD-XD4OszZL-qdM
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import least_squares
import pandas as pd
import os
#import tkinter as tk
#from tkinter import filedialog, messagebox, ttk
#from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import streamlit as st


import sys
import io
# Global variables
class OrbitData:
    def __init__(self):
        self.el = np.zeros(10)  # [P, T, e, a, W, w, i, K1, K2, V0]
        self.elerr = np.zeros(10)
        self.fixel = np.ones(10, dtype=int)
        self.elname = ['P', 'T', 'e', 'a', 'W', 'w', 'i', 'K1', 'K2', 'V0']
        self.pos = None
        self.rv1 = None
        self.rv2 = None
        self.obj = {'name': '', 'radeg': 0.0, 'dedeg': 0.0, 'npos': 0, 'nrv1': 0, 'nrv2': 0,
                    'rms': np.zeros(4), 'chi2n': np.zeros(4), 'chi2': 0.0, 'fname': '',
                    'parallax': 0.0}
        self.graph = {'mode': 0}

orb = OrbitData()

# Constants
G = 2945.98  # Gravitational constant in km^3 s^-2 M_sun^-1 day^-1

# Ephemeris calculation
def eph(el, t, rho=False, rv=False):
    n = len(t)
    res = np.zeros((n, 2), dtype=float)
    pi2 = 2 * np.pi
    gr = 180 / np.pi

    P, T, SF, a, W, w, i, K1, K2, V0 = el
    CF2 = 1 - SF**2
    CF = np.sqrt(CF2)
    EC = np.sqrt((1 + SF) / (1 - SF))
    CWW = np.cos(W / gr)
    SWW = np.sin(W / gr)
    CW = np.cos(w / gr)
    SW = np.sin(w / gr)
    CI = np.cos(i / gr)
    SI = np.sin(i / gr)

    if rv:
        for i in range(n):
            dt = t[i] - T
            phase = (dt / P) % 1
            if phase < 0:
                phase += 1
            ANM = phase * pi2
            E = ANM
            E1 = E + (ANM + SF * np.sin(E) - E) / (1 - SF * np.cos(E))
            while abs(E1 - E) > 1e-5:
                E = E1
                E1 = E + (ANM + SF * np.sin(E) - E) / (1 - SF * np.cos(E))
            V = 2 * np.arctan(EC * np.tan(E1 / 2))
            U = V + w / gr
            CU = np.cos(U)
            A1 = SF * CW + CU
            res[i, 0] = V0 + K1 * A1
            res[i, 1] = V0 - K2 * A1
    else:
        AA = a * (CW * CWW - SW * SWW * CI)
        BB = a * (CW * SWW + SW * CWW * CI)
        FF = a * (-SW * CWW - CW * SWW * CI)
        GG = a * (-SW * SWW + CW * CWW * CI)
        for i in range(n):
            dt = t[i] - T
            phase = (dt / P) % 1
            if phase < 0:
                phase += 1
            ANM = phase * pi2
            E = ANM
            E1 = E + (ANM + SF * np.sin(E) - E) / (1 - SF * np.cos(E))
            while abs(E1 - E) > 1e-5:
                E = E1
                E1 = E + (ANM + SF * np.sin(E) - E) / (1 - SF * np.cos(E))
            V = 2 * np.arctan(EC * np.tan(E1 / 2))
            CV = np.cos(V)
            R = CF2 / (1 + SF * CV)
            X = R * CV
            Y = R * np.sin(V)
            res[i, 0] = AA * X + FF * Y
            res[i, 1] = BB * X + GG * Y

    if rho:
        rho_vals = np.sqrt(res[:, 0]**2 + res[:, 1]**2)
        theta = np.arctan2(res[:, 1], res[:, 0]) * 180 / np.pi
        theta = (theta + 360) % 360
        res[:, 0] = theta
        res[:, 1] = rho_vals

    return res

# Coordinate parsing
def getcoord(s):
    l = s.find('.')
    deg = int(s[:l]) if l > 0 else int(s)
    min_part = float(s[l:]) if l > 0 else 0
    res = abs(deg) + min_part
    if float(s) < 0:
        res = -res
    return res

# Time correction
def correct(data, t0):
    time = data[:, 0]
    for i in range(len(time)):
        if time[i] < 3000 and t0 > 3000:
            data[i, 0] = 365.242198781 * (time[i] - 1900) + 15020.31352
        elif time[i] > 3000 and t0 < 3000:
            data[i, 0] = 1900 + (time[i] - 15020.31352) / 365.242198781

# Read input file
def readcsv_custom(fname):
    global orb
    orb.rv1_source = []
    orb.rv2_source = []
    orb.pos_source = []
    orb.el = np.zeros(10)
    orb.fixel = np.ones(10, dtype=int)
    orb.elerr = np.zeros(10)
    orb.obj = {'name': '', 'radeg': 0.0, 'dedeg': 0.0, 'npos': 0, 'nrv1': 0, 'nrv2': 0, 'rms': np.zeros(4), 'chi2n': np.zeros(4), 'chi2': 0.0, 'fname': fname, 'parallax': 0.0}
    nmax = 1000
    orb.pos = np.zeros((nmax, 6))
    orb.rv1 = np.zeros((nmax, 3))
    orb.rv2 = np.zeros((nmax, 3))

    with open(fname, 'r') as f:
        lines = f.readlines()

    kpos = 0
    krv1 = 0
    krv2 = 0

    for line in lines:
        # Normalize line (remove BOM, whitespace)
        line = line.lstrip('\ufeff').strip()
        #print(f"[TRACE] Raw line: '{line}'")  # DEBUG: show each line being read
        if not line:
            continue
        if line.startswith('#') or line.upper().startswith('C'):
            continue
        parts = [p.strip() for p in line.split(',') if p.strip()]
        #print(f"[TRACE] Split parts: {parts}")  # Debug output
        if not parts:
            continue

        # Metadata and elements
        if len(parts) == 2:
            key = parts[0].strip().lower()
            #print(key)  # Debug output
            val = parts[1].strip()
            if "object" in key:
                orb.obj['name'] = val
            elif "ra" in key:
                orb.obj['radeg'] = 15 * getcoord(val)
            elif "dec" in key:
                orb.obj['dedeg'] = getcoord(val)
            elif "par" in key:
                orb.obj['parallax'] = float(val)
                #print(f"DEBUG: Parallax read = {orb.obj['parallax']}")
            elif parts[0] in orb.elname:
                idx = orb.elname.index(parts[0])
                orb.el[idx] = float(parts[1])
                orb.fixel[idx] = 1
            continue
        # RV1 (Va)
        if parts[-2] == "Va" and len(parts) >= 5:
            orb.rv1[krv1, 0:3] = [float(parts[0]), float(parts[1]), float(parts[2])]
            orb.rv1_source.append(parts[4])  # COR, for example
            krv1 += 1

        # RV2 (Vb)
        elif parts[-2] == "Vb" and len(parts) >= 5:
            orb.rv2[krv2, 0:3] = [float(parts[0]), float(parts[1]), float(parts[2])]
            orb.rv2_source.append(parts[4])
            krv2 += 1

        # POS (I1)
        elif parts[-2] == "I1" and len(parts) >= 6:
            orb.pos[kpos, 0:4] = [float(parts[0]), float(parts[1]), float(parts[2]), float(parts[3])]
            orb.pos_source.append(parts[5])
            kpos += 1
    #print(f"DEBUG: Parallax read = {orb.obj['parallax']}")


    # Truncate arrays
    orb.rv1 = orb.rv1[:krv1, :] if krv1 > 0 else np.array([])
    orb.rv2 = orb.rv2[:krv2, :] if krv2 > 0 else np.array([])
    orb.pos = orb.pos[:kpos, :] if kpos > 0 else np.array([])
    orb.obj['nrv1'] = krv1
    orb.obj['nrv2'] = krv2
    orb.obj['npos'] = kpos

    if krv1 > 0:
        correct(orb.rv1, orb.el[1])
    if krv2 > 0:
        correct(orb.rv2, orb.el[1])
    if kpos > 0:
        correct(orb.pos, orb.el[1])

    orb.graph['mode'] = 1 if (krv1 > 0 or krv2 > 0) else 0

def readinp(fname):
    global orb
    orb.el = np.zeros(10)
    orb.fixel = np.ones(10, dtype=int)
    nmax = 500
    orb.pos = np.zeros((nmax, 6))
    orb.rv1 = np.zeros((nmax, 3))
    orb.rv2 = np.zeros((nmax, 3))
    orb.obj['fname'] = fname

    if not os.path.exists(fname):
        print(f"File {fname} not found")
        orb.obj['fname'] = ''
        return

    with open(fname, 'r') as f:
        lines = f.readlines()

    kpos = 0
    krv1 = 0
    krv2 = 0
    for i, line in enumerate(lines):
        line = line.strip()
        if line.startswith('C'):
            continue
        fix = 0 if line.startswith('*') else 1
        parts = line.split()
        if not parts:
            continue
        if parts[0] == 'Object:':
            orb.obj['name'] = ' '.join(parts[1:])
        elif parts[0] == 'RA:':
            orb.obj['radeg'] = 15 * getcoord(parts[1])
        elif parts[0] == 'Dec:':
            orb.obj['dedeg'] = getcoord(parts[1])
        elif parts[0] == 'Parallax:':
            orb.obj['parallax'] = float(parts[1])
        elif parts[0] in orb.elname:
            ind = orb.elname.index(parts[0])
            orb.el[ind] = float(parts[1])
            orb.fixel[ind] = fix
        elif 'I1' in line and len(parts) >= 4:
            orb.pos[kpos, 0:4] = [float(p) for p in parts[0:4]]
            kpos += 1
        elif 'Va' in line and len(parts) >= 3:
            orb.rv1[krv1, 0:3] = [float(p) for p in parts[0:3]]
            krv1 += 1
        elif 'Vb' in line and len(parts) >= 3:
            orb.rv2[krv2, 0:3] = [float(p) for p in parts[0:3]]
            krv2 += 1

    orb.pos = orb.pos[:kpos, :] if kpos > 0 else np.array([])
    orb.rv1 = orb.rv1[:krv1, :] if krv1 > 0 else np.array([])
    orb.rv2 = orb.rv2[:krv2, :] if krv2 > 0 else np.array([])

    if kpos > 0:
        correct(orb.pos, orb.el[1])
    if krv1 > 0:
        correct(orb.rv1, orb.el[1])
    if krv2 > 0:
        correct(orb.rv2, orb.el[1])

    print(f"Position measures: {kpos}")
    print(f"RV measures: {krv1}, {krv2}")
    orb.obj['npos'] = kpos
    orb.obj['nrv1'] = krv1
    orb.obj['nrv2'] = krv2
    orb.elerr = np.zeros(10)
    orb.graph['mode'] = 1 if (krv1 > 0 or krv2 > 0) else 0
    # Modifed by M.H. TALAFHA 20/05/2025
    # If radial velocities are not included in the data file, you have to fix some paramters to ensure perfect fitting
    # We have 10 parameters 'P', 'T', 'e', 'a', 'W', 'w', 'i', 'K1', 'K2', 'V0'
    # if you want to fix the last 3 for example you should slice the array [7:10]
    # if more needed to be fixed slice the array [5:10], this will fix the last 5 parameters
    #if krv1 == 0 and krv2 == 0:
    #  orb.fixel[7:10] = 0  # Fix K1, K2, V0
    #  print("No RV data, fixing K1, K2, V0")

# Orbit plotting
def orbplot_streamlit():
    import matplotlib.pyplot as plt
    figs = []
    name = orb.obj['fname'].split('.')[0]

    gr = 180 / np.pi

    # --- Visual Orbit Plot ---
    if orb.obj['npos'] > 0:
        fig, ax = plt.subplots(figsize=(6, 6))
        time = np.linspace(0, orb.el[0], 100) + orb.el[1]
        xye = eph(orb.el, time)
        xobs = -orb.pos[:, 2] * np.sin(orb.pos[:, 1] / gr)
        yobs = orb.pos[:, 2] * np.cos(orb.pos[:, 1] / gr)
        xy0 = eph(orb.el, orb.pos[:, 0])

        ax.plot(-xye[:, 1], xye[:, 0], 'k-', label='Orbit')
        ax.plot(xobs, yobs, 'bs', label='Observations')
        for i in range(len(xobs)):
            ax.plot([xobs[i], -xy0[i, 1]], [yobs[i], xy0[i, 0]], 'k--')
            year = int(round(orb.pos[i, 0]))
            ax.text(xobs[i], yobs[i], str(year), fontsize=8)
        ax.plot([0], [0], 'r*', markersize=10, label='Center')
        ax.set_xlabel('X, arcsec (East)')
        ax.set_ylabel('Y, arcsec (North)')
        ax.set_title(f"Visual Orbit of {orb.obj['name']}")
        ax.axis('equal')
        ax.legend()
        figs.append(fig)

    # --- RV vs Time Plot ---
    if orb.obj['nrv1'] > 0 or orb.obj['nrv2'] > 0:
        t_all = np.concatenate([
            orb.rv1[:, 0] if orb.obj['nrv1'] > 0 else [],
            orb.rv2[:, 0] if orb.obj['nrv2'] > 0 else []
        ])
        t = np.linspace(min(t_all), max(t_all), 100)
        rv = eph(orb.el, t, rv=True)

        fig2, ax2 = plt.subplots(figsize=(8, 5))
        if orb.obj['nrv1'] > 0:
            ax2.errorbar(orb.rv1[:, 0], orb.rv1[:, 1], yerr=orb.rv1[:, 2], fmt='bo', label='Primary RV')
            ax2.plot(t, rv[:, 0], 'b-', label='Primary Fit')
        if orb.obj['nrv2'] > 0:
            ax2.errorbar(orb.rv2[:, 0], orb.rv2[:, 1], yerr=orb.rv2[:, 2], fmt='ro', label='Secondary RV')
            ax2.plot(t, rv[:, 1], 'r--', label='Secondary Fit')

        ax2.set_xlabel('Time (JD)')
        ax2.set_ylabel('Radial Velocity (km/s)')
        ax2.set_title(f"RV Curve of {orb.obj['name']} vs Time")
        ax2.legend()
        figs.append(fig2)

        # --- RV vs Phase Plot ---
        fig3, ax3 = plt.subplots(figsize=(8, 5))
        phases = np.linspace(0, 1, 100)
        t_phase = phases * orb.el[0] + orb.el[1]
        rv_phase = eph(orb.el, t_phase, rv=True)

        if orb.obj['nrv1'] > 0:
            phase1 = ((orb.rv1[:, 0] - orb.el[1]) / orb.el[0]) % 1
            ax3.errorbar(phase1, orb.rv1[:, 1], yerr=orb.rv1[:, 2], fmt='bo', label='Primary RV')
            ax3.plot(phases, rv_phase[:, 0], 'b-', label='Primary Fit')
        if orb.obj['nrv2'] > 0:
            phase2 = ((orb.rv2[:, 0] - orb.el[1]) / orb.el[0]) % 1
            ax3.errorbar(phase2, orb.rv2[:, 1], yerr=orb.rv2[:, 2], fmt='ro', label='Secondary RV')
            ax3.plot(phases, rv_phase[:, 1], 'r--', label='Secondary Fit')

        ax3.set_xlabel('Phase')
        ax3.set_ylabel('Radial Velocity (km/s)')
        ax3.set_title(f"RV Curve of {orb.obj['name']} vs Phase")
        ax3.legend()
        figs.append(fig3)

    return figs
def orbplot(ps=False):
    global orb
    name = orb.obj['fname'].split('.')[0]

    if orb.obj['npos'] > 0:
        plt.figure(figsize=(6, 6))
        time = np.linspace(0, orb.el[0], 100) + orb.el[1]
        xye = eph(orb.el, time)
        gr = 180 / np.pi
        xobs = -orb.pos[:, 2] * np.sin(orb.pos[:, 1] / gr)
        yobs = orb.pos[:, 2] * np.cos(orb.pos[:, 1] / gr)
        xy0 = eph(orb.el, orb.pos[:, 0])

        plt.plot(-xye[:, 1], xye[:, 0], 'k-', label='Orbit')
        plt.plot(xobs, yobs, 'bs', label='Observations')
        for i in range(len(xobs)):
            plt.plot([xobs[i], -xy0[i, 1]], [yobs[i], xy0[i, 0]], 'k--')
            year = int(round(orb.pos[i, 0]))
            plt.text(xobs[i], yobs[i], str(year), fontsize=8)
        plt.plot([0], [0], 'r*', markersize=10, label='Center')
        plt.xlabel('X, arcsec (East)')
        plt.ylabel('Y, arcsec (North)')
        plt.title(f"Visual Orbit of {orb.obj['name']}")
        plt.axis('equal')
        plt.legend()
        if ps:
            plt.savefig(f"{name}_POS.png")
            #files.download(f"{name}_POS.png")
        #st.pyplot(plt.gcf())

    if orb.obj['nrv1'] > 0 or orb.obj['nrv2'] > 0:
        plt.figure(figsize=(8, 6))
        t = np.linspace(min(np.concatenate([orb.rv1[:, 0] if orb.obj['nrv1'] > 0 else np.array([]),
                                           orb.rv2[:, 0] if orb.obj['nrv2'] > 0 else np.array([])])),
                       max(np.concatenate([orb.rv1[:, 0] if orb.obj['nrv1'] > 0 else np.array([]),
                                           orb.rv2[:, 0] if orb.obj['nrv2'] > 0 else np.array([])])),
                       100)
        rv = eph(orb.el, t, rv=True)

        if orb.obj['nrv1'] > 0:
            plt.errorbar(orb.rv1[:, 0], orb.rv1[:, 1], yerr=orb.rv1[:, 2], fmt='bo', label='Primary RV')
        if orb.obj['nrv2'] > 0:
            plt.errorbar(orb.rv2[:, 0], orb.rv2[:, 1], yerr=orb.rv2[:, 2], fmt='ro', label='Secondary RV')

        if orb.obj['nrv1'] > 0:
            plt.plot(t, rv[:, 0], 'b-', label='Primary Fit')
        if orb.obj['nrv2'] > 0:
            plt.plot(t, rv[:, 1], 'r--', label='Secondary Fit')

        plt.xlabel('Time (JD)')
        plt.ylabel('Radial Velocity (km/s)')
        plt.title(f"RV Curve of {orb.obj['name']} vs Time")
        plt.legend()
        if ps:
            plt.savefig(f"{name}_RV_time.png")
            #files.download(f"{name}_RV_time.png")
        #st.pyplot(plt.gcf())

        plt.figure(figsize=(8, 6))
        t_phase = np.linspace(0, orb.el[0], 100) + orb.el[1]
        rv = eph(orb.el, t_phase, rv=True)
        phases = np.linspace(0, 1, 100)

        if orb.obj['nrv1'] > 0:
            phase1 = ((orb.rv1[:, 0] - orb.el[1]) / orb.el[0]) % 1
            phase1[phase1 < 0] += 1
            plt.errorbar(phase1, orb.rv1[:, 1], yerr=orb.rv1[:, 2], fmt='bo', label='Primary RV')
        if orb.obj['nrv2'] > 0:
            phase2 = ((orb.rv2[:, 0] - orb.el[1]) / orb.el[0]) % 1
            phase2[phase2 < 0] += 1
            plt.errorbar(phase2, orb.rv2[:, 1], yerr=orb.rv2[:, 2], fmt='ro', label='Secondary RV')

        if orb.obj['nrv1'] > 0:
            plt.plot(phases, rv[:, 0], 'b-', label='Primary Fit')
        if orb.obj['nrv2'] > 0:
            plt.plot(phases, rv[:, 1], 'r--', label='Secondary Fit')

        plt.xlabel('Phase')
        plt.ylabel('Radial Velocity (km/s)')
        plt.title(f"RV Curve of {orb.obj['name']} vs Phase")
        plt.legend()
        if ps:
            plt.savefig(f"{name}_RV_phase.png")
            #files.download(f"{name}_RV_phase.png")
        #st.pyplot(plt.gcf())

# Fit orbital elements
def alleph(params, i):
    global orb
    selfit = np.where(orb.fixel > 0)[0]
    el0 = orb.el.copy()
    el0[selfit] = params
    e = 0.01
    del_vals = [e * el0[0], e * el0[0], e, e * el0[3], 1, 1, 1, e * el0[7], e * el0[8], e * el0[7]]

    if i < 2 * orb.obj['npos']:
        j = 1 if i >= orb.obj['npos'] else 0
        time = orb.pos[i - j * orb.obj['npos'], 0]
        res = eph(el0, [time], rho=True)[0, j]
        deriv = np.zeros(10)
        for k in range(10):
            if orb.fixel[k] > 0:
                el1 = el0.copy()
                el1[k] += del_vals[k]
                deriv[k] = (eph(el1, [time], rho=True)[0, j] - res) / del_vals[k]
        return np.concatenate([[res], deriv[selfit]])
    elif i < 2 * orb.obj['npos'] + orb.obj['nrv1']:
        time = orb.rv1[i - 2 * orb.obj['npos'], 0]
        res = eph(el0, [time], rv=True)[0, 0]
        deriv = np.zeros(10)
        for k in range(10):
            if orb.fixel[k] > 0:
                el1 = el0.copy()
                el1[k] += del_vals[k]
                deriv[k] = (eph(el1, [time], rv=True)[0, 0] - res) / del_vals[k]
        return np.concatenate([[res], deriv[selfit]])
    elif i < 2 * orb.obj['npos'] + orb.obj['nrv1'] + orb.obj['nrv2']:
        time = orb.rv2[i - 2 * orb.obj['npos'] - orb.obj['nrv1'], 0]
        res = eph(el0, [time], rv=True)[0, 1]
        deriv = np.zeros(10)
        for k in range(10):
            if orb.fixel[k] > 0:
                el1 = el0.copy()
                el1[k] += del_vals[k]
                deriv[k] = (eph(el1, [time], rv=True)[0, 1] - res) / del_vals[k]
        return np.concatenate([[res], deriv[selfit]])
    return np.zeros(len(selfit) + 1)

def fitorb(rms_only=False):
    global orb
    npos = orb.obj['npos']
    nrv1 = orb.obj['nrv1']
    nrv2 = orb.obj['nrv2']
    n = 2 * npos + nrv1 + nrv2
    yy = np.zeros(n)
    err = np.zeros(n)

    if npos > 0:
        yy[:npos] = orb.pos[:, 1]  # Position angles
        err[:npos] = orb.pos[:, 3] * 180 / np.pi / orb.pos[:, 2]  # Angular error approximation
        yy[npos:2*npos] = orb.pos[:, 2]  # Separations
        err[npos:2*npos] = orb.pos[:, 3]  # Separation errors
    if nrv1 > 0:
        yy[2*npos:2*npos+nrv1] = orb.rv1[:, 1]
        err[2*npos:2*npos+nrv1] = orb.rv1[:, 2]
    if nrv2 > 0:
        yy[2*npos+nrv1:] = orb.rv2[:, 1]
        err[2*npos+nrv1:] = orb.rv2[:, 2]

    selfit = np.where(orb.fixel > 0)[0]
    print(f"Fitting {len(selfit)} elements: {[orb.elname[i] for i in selfit]}")
    print(f"Total observations: {n} (npos={npos}, nrv1={nrv1}, nrv2={nrv2})")
    par = orb.el[selfit]
    def residuals(params):
      y1 = np.array([alleph(params, i)[0] for i in range(n)])
      return (yy - y1) / err
    if rms_only:
        y1 = np.array([alleph(par, i)[0] for i in range(n)])
    else:
        result = least_squares(residuals, par, method='lm', max_nfev=1000, ftol=1e-10, xtol=1e-10, verbose=2)
        par = result.x
        y1 = yy - result.fun * err
        orb.el[selfit] = par

        n_params = len(selfit)
        dof = n - n_params
        print(f"Degrees of freedom: {dof}")
        if dof > 0:
            chi2 = np.sum(result.fun**2)
            reduced_chi2 = chi2 / dof
            print(f"Chi-squared: {chi2:.4f}, Reduced Chi-squared: {reduced_chi2:.4f}")

            J = np.array([alleph(par, i)[1:] for i in range(n)])
            print(f"Jacobian shape: {J.shape}")

            try:
                JTJ = J.T @ J
                print(f"JTJ condition number: {np.linalg.cond(JTJ):.2e}")
                cov = np.linalg.inv(JTJ) * reduced_chi2
                errors = np.sqrt(np.diag(cov))
                orb.elerr[selfit] = errors
                print("Covariance matrix computed successfully")
            except np.linalg.LinAlgError as e:
                print(f"Error computing covariance: {e}")
                print("Using approximate errors")
                orb.elerr[selfit] = np.abs(J.T @ result.fun) * np.sqrt(reduced_chi2) / n
        else:
            print("Warning: Not enough degrees of freedom for error estimation")
            orb.elerr[selfit] = np.zeros(len(selfit))

    wt = 1 / err**2
    resid2 = (yy - y1)**2 * wt
    nmin = [0, npos, 2*npos, 2*npos+nrv1]
    nmax = [npos, 2*npos, 2*npos+nrv1, n]
    ndat = [nmax[i] - nmin[i] for i in range(4)]
    sd = [np.sum(resid2[nmin[j]:nmax[j]]) if ndat[j] > 0 else 0 for j in range(4)]
    wsum = [np.sum(wt[nmin[j]:nmax[j]]) if ndat[j] > 0 else 0 for j in range(4)]
    normchi2 = [sd[j] / ndat[j] if ndat[j] > 0 else 0 for j in range(4)]
    wrms = [np.sqrt(sd[j] / wsum[j]) if wsum[j] > 0 else 0 for j in range(4)]

    print(f"CHI2/N: {normchi2}")
    print(f"RMS (Theta, rho, RV1, RV2): {wrms}")
    print("\nFitted Parameters and Errors:")
    for i, idx in enumerate(selfit):
        print(f"{orb.elname[idx]:<5}: {orb.el[idx]:>10.4f} ± {orb.elerr[idx]:.4f}")

    orb.obj['rms'] = wrms
    orb.obj['chi2n'] = normchi2
    if not rms_only:
        orb.obj['chi2'] = np.sum((yy - y1)**2 / err**2)
        orbplot()

    return yy, y1

# Calculate total mass
def calculate_total_mass(P, a, parallax):
    if parallax <= 0:
        return 0.0
    distance_pc = 1000.0 / parallax
    a_au = a * distance_pc
    total_mass = (a_au**3) / (P**2)
    return total_mass

# Calculate spectroscopic masses
def calculate_spectroscopic_masses(P, e, i, K1, K2):
    if K1 == 0 and K2 == 0:
        return 0.0, 0.0, 0.0

    i_rad = np.radians(i)
    sin_i = np.sin(i_rad)
    sin3_i = sin_i**3
    K_sum = K1 + K2

    # M(1+2) * sin^3(i) in solar masses
    M12_sin3i = (K_sum**3 * P * (1 - e**2)**(3/2)) / (2 * np.pi * G)

    q = K1 / K2 if K2 != 0 else float('inf')
    if q != float('inf'):
        M_total = M12_sin3i / sin3_i
        M1 = M_total / (1 + q)
        M2 = q * M1
    else:
        M1 = M12_sin3i / sin3_i
        M2 = 0.0

    return M12_sin3i, M1, M2

# Save results
def orbsave():
    global orb
    name = orb.obj['fname'].split('.')[0]
    outfile = f"{name}_output.csv"

    elements_data = {
        'Parameter': orb.elname,
        'Value': orb.el,
        'Error': orb.elerr,
        'Fixed': orb.fixel
    }
    elements_df = pd.DataFrame(elements_data)

    if orb.obj['npos'] > 0:
        res = eph(orb.el, orb.pos[:, 0], rho=True)
        pos_data = {
            'Time': orb.pos[:, 0],
            'PA_Obs': orb.pos[:, 1],
            'Rho_Obs': orb.pos[:, 2],
            'Err': orb.pos[:, 3],
            'PA_Fit': res[:, 0],
            'Rho_Fit': res[:, 1]
        }
        pos_df = pd.DataFrame(pos_data)
    else:
        pos_df = pd.DataFrame()

    if orb.obj['nrv1'] > 0:
        rv1_fit = eph(orb.el, orb.rv1[:, 0], rv=True)[:, 0]
        rv1_data = {
            'Time': orb.rv1[:, 0],
            'RV_Obs': orb.rv1[:, 1],
            'Err': orb.rv1[:, 2],
            'RV_Fit': rv1_fit
        }
        rv1_df = pd.DataFrame(rv1_data)
    else:
        rv1_df = pd.DataFrame()

    if orb.obj['nrv2'] > 0:
        rv2_fit = eph(orb.el, orb.rv2[:, 0], rv=True)[:, 1]
        rv2_data = {
            'Time': orb.rv2[:, 0],
            'RV_Obs': orb.rv2[:, 1],
            'Err': orb.rv2[:, 2],
            'RV_Fit': rv2_fit
        }
        rv2_df = pd.DataFrame(rv2_data)
    else:
        rv2_df = pd.DataFrame()

    total_mass = calculate_total_mass(orb.el[0], orb.el[3], orb.obj['parallax'])
    M12_sin3i, M1, M2 = calculate_spectroscopic_masses(orb.el[0], orb.el[2], orb.el[6], orb.el[7], orb.el[8])

    stats_data = {
        'Metric': ['CHI2', 'CHI2/N_Theta', 'CHI2/N_Rho', 'CHI2/N_RV1', 'CHI2/N_RV2',
                  'RMS_Theta', 'RMS_Rho', 'RMS_RV1', 'RMS_RV2', 'Parallax_mas',
                  'Total_Mass_Msun', 'M(1+2)_sin3i', 'M1_Msun', 'M2_Msun'],
        'Value': [orb.obj['chi2'], orb.obj['chi2n'][0], orb.obj['chi2n'][1], orb.obj['chi2n'][2],
                 orb.obj['chi2n'][3], orb.obj['rms'][0], orb.obj['rms'][1], orb.obj['rms'][2],
                 orb.obj['rms'][3], orb.obj['parallax'], total_mass, M12_sin3i, M1, M2]
    }
    stats_df = pd.DataFrame(stats_data)

    with open(outfile, 'w') as f:
        f.write(f"# Object: {orb.obj['name']}\n")
        f.write(f"# RA: {orb.obj['radeg']/15:.6f}\n")
        f.write(f"# Dec: {orb.obj['dedeg']:.6f}\n")
        f.write(f"# Parallax (mas): {orb.obj['parallax']:.6f}\n")
        f.write("\n# Orbital Elements\n")
        elements_df.to_csv(f, index=False)
        if not pos_df.empty:
            f.write("\n# Position Measurements\n")
            pos_df.to_csv(f, index=False)
        if not rv1_df.empty:
            f.write("\n# Primary RV Measurements\n")
            rv1_df.to_csv(f, index=False)
        if not rv2_df.empty:
            f.write("\n# Secondary RV Measurements\n")
            rv2_df.to_csv(f, index=False)
        f.write("\n# Statistics\n")
        stats_df.to_csv(f, index=False)

    print(f"Results saved to {outfile}")
    #files.download(outfile)
    if orb.obj['parallax'] > 0:
        print(f"Total system mass: {total_mass:.3f} solar masses")
    else:
        print("Parallax not provided, cannot calculate total mass")

    print("\nSpectroscopic masses:")
    print(f"M(1+2)*sin^3(i) = {M12_sin3i:.6f} solar masses")
    print(f"M1 = {M1:.6f} solar masses")
    print(f"M2 = {M2:.6f} solar masses")

# --- Local GUI Interface using Tkinter ---

'''
def run_gui():
    def upload_and_run():
        file_path = filedialog.askopenfilename(filetypes=[("Input files", "*.inp")])
        if not file_path:
            return
        try:
            readinp(file_path)

            # Fix parameters if no RV data
            if orb.obj['nrv1'] == 0 and orb.obj['nrv2'] == 0:
                orb.fixel[7:10] = 0  # Fix K1, K2, V0
                orb.fixel[4:7] = 0   # Fix W, w, i optionally for more stability
                print("No RV data: fixing K1, K2, V0, W, w, i")

            fitorb()
            orbsave()
            messagebox.showinfo("Success", "Fitting completed and results saved.")
        except Exception as e:
            messagebox.showerror("Error", str(e))

    root = tk.Tk()
    root.title("Orbital Fitting Tool")
    root.geometry("400x150")

    label = tk.Label(root, text="Upload .inp file for orbital fitting", pady=10)
    label.pack()

    button = tk.Button(root, text="Upload and Fit", command=upload_and_run)
    button.pack(pady=10)

    root.mainloop()

#if __name__ == "__main__":
#    run_gui()

# --- Advanced Local GUI Interface using Tkinter ---


class RedirectText(io.StringIO):
    def __init__(self, text_widget):
        super().__init__()
        self.text_widget = text_widget

    def write(self, string):
        self.text_widget.insert(tk.END, string)
        self.text_widget.see(tk.END)

    def flush(self):
        pass

def run_gui():
    class RedirectText(io.StringIO):
        def __init__(self, text_widget):
            super().__init__()
            self.text_widget = text_widget

        def write(self, string):
            self.text_widget.insert(tk.END, string)
            self.text_widget.see(tk.END)
            self.text_widget.update_idletasks()  # Ensure update

        def flush(self):
            pass

    def upload_file():
        path = filedialog.askopenfilename(filetypes=[("Input files", "*.inp")])
        if path:
            file_entry.delete(0, tk.END)
            file_entry.insert(0, path)

    def update_fixel_checkboxes():
        for i, var in enumerate(fixel_vars):
            orb.fixel[i] = var.get()

    def run_fit():
        file_path = file_entry.get()
        if not os.path.isfile(file_path):
            messagebox.showerror("Error", "Invalid file path.")
            return
        try:
            output_text.delete("1.0", tk.END)  # Clear previous output

            # Redirect stdout
            redirector = RedirectText(output_text)
            sys.stdout = redirector
            sys.stderr = redirector

            readinp(file_path)
            update_fixel_checkboxes()
            fitorb()
            orbsave()

            print("\nFitting completed successfully.\n")

        except Exception as e:
            print(f"\n❌ Error: {str(e)}")
            messagebox.showerror("Error", str(e))
        finally:
            sys.stdout = sys.__stdout__  # Reset to default
            sys.stderr = sys.__stderr__

    root = tk.Tk()
    root.title("Advanced Orbital Fitting Tool")
    root.geometry("800x600")

    # File selection
    tk.Label(root, text="Select .inp File:").pack(pady=5)
    file_frame = tk.Frame(root)
    file_entry = tk.Entry(file_frame, width=60)
    file_entry.pack(side=tk.LEFT, padx=5)
    browse_button = tk.Button(file_frame, text="Browse", command=upload_file)
    browse_button.pack(side=tk.LEFT)
    file_frame.pack()

    # Fix element toggles
    tk.Label(root, text="Fix Parameters During Fit:").pack(pady=5)
    fixel_frame = tk.Frame(root)
    fixel_vars = []
    elnames = ['P', 'T', 'e', 'a', 'W', 'w', 'i', 'K1', 'K2', 'V0']
    for name in elnames:
        var = tk.IntVar(value=1)
        cb = tk.Checkbutton(fixel_frame, text=name, variable=var)
        cb.pack(side=tk.LEFT)
        fixel_vars.append(var)
    fixel_frame.pack()

    # Buttons
    button_frame = tk.Frame(root)
    run_button = tk.Button(button_frame, text="Run Fitting and Save", command=run_fit, bg='green', fg='white')
    exit_button = tk.Button(button_frame, text="Exit", command=root.quit, bg='red', fg='white')
    run_button.pack(side=tk.LEFT, padx=10)
    exit_button.pack(side=tk.LEFT, padx=10)
    button_frame.pack(pady=15)

    # Output display box
    output_text = tk.Text(root, height=20, width=100, wrap=tk.WORD)
    output_text.pack(pady=10)

    root.mainloop()


def run_fit():
    file_path = file_entry.get()
    if not os.path.isfile(file_path):
        messagebox.showerror("Error", "Invalid file path.")
        return
    try:
        output_text.delete("1.0", tk.END)  # Clear previous output
        sys.stdout = RedirectText(output_text)  # Redirect print statements

        readinp(file_path)
        update_fixel_checkboxes()
        fitorb()
        orbsave()
        messagebox.showinfo("Success", "Fitting completed and results saved.")
        
        sys.stdout = sys.__stdout__  # Reset redirect
    except Exception as e:
        sys.stdout = sys.__stdout__  # Ensure reset on error
        messagebox.showerror("Error", str(e))

    def plot_orbit():
        fig = plt.figure(figsize=(5, 5))
        ax = fig.add_subplot(111)
        if orb.obj['npos'] > 0:
            gr = 180 / np.pi
            xobs = -orb.pos[:, 2] * np.sin(orb.pos[:, 1] / gr)
            yobs = orb.pos[:, 2] * np.cos(orb.pos[:, 1] / gr)
            ax.plot(xobs, yobs, 'bo', label='Observed')
            xye = eph(orb.el, np.linspace(0, orb.el[0], 200) + orb.el[1])
            ax.plot(-xye[:, 1], xye[:, 0], 'r-', label='Fitted Orbit')
            ax.plot(0, 0, 'k*', markersize=10, label='Center')
            ax.set_title(f"Visual Orbit of {orb.obj['name']}")
            ax.set_xlabel("X (arcsec)")
            ax.set_ylabel("Y (arcsec)")
            ax.legend()
            ax.axis('equal')
        canvas = FigureCanvasTkAgg(fig, master=root)
        canvas.draw()
        canvas.get_tk_widget().pack(pady=10)

    root = tk.Tk()
    root.title("Advanced Orbital Fitting Tool")
    root.geometry("600x200")

    # File selection
    tk.Label(root, text="Select .inp File:").pack(pady=5)
    file_frame = tk.Frame(root)
    file_entry = tk.Entry(file_frame, width=50)
    file_entry.pack(side=tk.LEFT, padx=5)
    browse_button = tk.Button(file_frame, text="Browse", command=upload_file)
    browse_button.pack(side=tk.LEFT)
    file_frame.pack()

    # Fix element toggles
    tk.Label(root, text="Fix Parameters During Fit:").pack(pady=5)
    fixel_frame = tk.Frame(root)
    fixel_vars = []
    elnames = ['P', 'T', 'e', 'a', 'W', 'w', 'i', 'K1', 'K2', 'V0']
    for name in elnames:
        var = tk.IntVar(value=1)
        cb = tk.Checkbutton(fixel_frame, text=name, variable=var)
        cb.pack(side=tk.LEFT)
        fixel_vars.append(var)
    fixel_frame.pack()

    # Run and Exit buttons in a row
    button_frame = tk.Frame(root)
    run_button = tk.Button(button_frame, text="Run Fitting and Save", command=run_fit, bg='green', fg='white')
    exit_button = tk.Button(button_frame, text="Exit", command=root.quit, bg='red', fg='white')
    run_button.pack(side=tk.LEFT, padx=10)
    exit_button.pack(side=tk.LEFT, padx=10)
    button_frame.pack(pady=15)
    root.mainloop()

if __name__ == "__main__":
    run_gui()
    '''
